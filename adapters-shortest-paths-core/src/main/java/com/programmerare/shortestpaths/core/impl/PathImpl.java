package com.programmerare.shortestpaths.core.impl;

import static com.programmerare.shortestpaths.core.impl.WeightImpl.SMALL_DELTA_VALUE_FOR_WEIGHT_COMPARISONS;

import java.util.Collections;
import java.util.List;

import com.programmerare.shortestpaths.core.api.Edge;
import com.programmerare.shortestpaths.core.api.Path;
import com.programmerare.shortestpaths.core.api.Weight;

/**
 * @author Tomas Johansson
 */
public class PathImpl<T extends Edge> implements Path<T> {

	private final Weight totalWeight;
	private final List<T> edges;

	public static <T extends Edge> Path<T> createPath(final Weight totalWeight, final List<T> edges) {
		return createPath(totalWeight, edges, false, false);
	}

	/**
	 * 
	 * @param totalWeight
	 * @param edges
	 * @param shouldThrowExceptionIfTotalWeightIsMismatching
	 * @param shouldThrowExceptionIfAnyMismatchingVertex
	 * @return
	 */
	public static <T extends Edge> Path<T> createPath(
		final Weight totalWeight, 
		final List<T> edges, 
		boolean shouldThrowExceptionIfTotalWeightIsMismatching, 
		boolean shouldThrowExceptionIfAnyMismatchingVertex
	) {
		if(shouldThrowExceptionIfTotalWeightIsMismatching) {
			if(isTotalWeightNotCorrect(edges, totalWeight)) {
				throw new RuntimeException("Incorrect weight " + totalWeight + " not mathcing the sum of the edges " + edges);
			}			
		}
		if(shouldThrowExceptionIfAnyMismatchingVertex) {
			if(isAnyVertexMismatching(edges)) {
				throw new RuntimeException("Mismatching vertices detected " + edges);
			}
		}
		return new PathImpl<T>(totalWeight, edges, shouldThrowExceptionIfTotalWeightIsMismatching, shouldThrowExceptionIfAnyMismatchingVertex);
	}	
	
	private static <T extends Edge> boolean isTotalWeightNotCorrect(List<T> edges, Weight totalWeight) {
		double tot = 0;
		for (T edge : edges) {
			tot += edge.getEdgeWeight().getWeightValue();
		}
		return Math.abs(totalWeight.getWeightValue() - tot) > SMALL_DELTA_VALUE_FOR_WEIGHT_COMPARISONS;
	}

	private static <T extends Edge> boolean isAnyVertexMismatching(List<T> edges) {
		for (int i = 1; i < edges.size(); i++) {
			Edge edge = edges.get(i-1);
			Edge nextEdge = edges.get(i);
			if(!edge.getEndVertex().equals(nextEdge.getStartVertex())) {
				return true;
			}
		}
		return false;
	}

	private PathImpl(
		final Weight totalWeight, 
		final List<T> edges, 
		boolean shouldThrowExceptionIfTotalWeightIsMismatching, 
		boolean shouldThrowExceptionIfAnyMismatchingVertex
	) {
		this.totalWeight = totalWeight;
		this.edges = Collections.unmodifiableList(edges);
	}	
	
	public Weight getTotalWeightForPath() {
		return totalWeight;
	}

	public List<T> getEdgesForPath() {
		return edges;
	}

	// The three methods below were generated by Eclipse
	
	@Override
	public String toString() {
		return "PathImpl [totalWeight=" + totalWeight + ", edges=" + edges + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((edges == null) ? 0 : edges.hashCode());
		result = prime * result + ((totalWeight == null) ? 0 : totalWeight.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof PathImpl))
			return false;
		PathImpl other = (PathImpl) obj;
		if (edges == null) {
			if (other.edges != null)
				return false;
		} else if (!edges.equals(other.edges))
			return false;
		if (totalWeight == null) {
			if (other.totalWeight != null)
				return false;
		} else if (!totalWeight.equals(other.totalWeight))
			return false;
		return true;
	}
	
}
